desc:MIDI d'Arpagnan
author: jahudka
version: 1.0
changelog: Fresh out of the oven
about:
  # d'Arpagnan Arpeggiator

  I created d'Arpagnan because I wanted a simple-to-use, _predictable_,
  and still powerful arpeggiator, but I couldn't find anything that
  works and does what I need. So I rolled my own. Please beware that
  I put this together in an afternoon and it works _for me_ - it may
  not work for you, or you might not like the way it does.

  It doesn't have a fancy step sequencer. It just takes whatever you play
  and makes a sequence out of it using a deterministic algorithm with
  only a couple of parameters. You can play it live. You can use it
  in the studio. You can print out the source code and make an origami.
  Your imagination is the limit.

  ## Controls

   - `Step size` is pretty self-explanatory, I think.
   - `Algorithm` offers four choices:
      - `up` plays the notes from the lowest to the highest,
      - `down` does the mirror opposite,
      - `up&down` does one `up` and then one `down` (e.g. `cegCCgeccegCCgec...`), and
      - `up&down alt` does the same, except it deduplicates
        the last note of each cycle, so for example `cegCgecegCgec...`.
   - `Octaves` is used to add octaves above the played notes. It does exactly
     the same thing as if you added transposed copies of all the notes you play.
   - `Note length` can be used to make the emitted notes shorter.
     By default the notes are the full specified `Step size` long, but
     at 1/32 triplets at 180bpm stuff gets crazy sometimes and notes could
     overlap, and overlapping notes could cause hanging tones. Bringing
     note length back to 90% can be usually compensated by a slightly longer
     decay on the synth to sound the same while avoiding this issue.
   - `Retrigger` allows you to choose whether to restart the sequence
     from the beginning when any one note is changed (ie. added or removed),
     or only when there's a period of silence (even if it's only a millisecond long).


slider1:0<0,9,1{Up,Down,Up/Down,Up/Down+,Down/Up,Down/Up+,Join,Spread,Join/Spread,Spread/Join}>Algorithm
slider2:1<1,4,1>Octaves
slider3:resolution=7<0,23,1{1/64 Triplet,1/64,1/64 Dotted,1/32 Triplet,1/32,1/32 Dotted,1/16 Triplet,1/16,1/16 Dotted,1/8 Triplet,1/8,1/8 Dotted,1/4 Triplet,1/4,1/4 Dotted,1/2 Triplet,1/2,1/2 Dotted,1/1 Triplet,1/1,1/1 Dotted,2/1 Triplet,2/1,2/1 Dotted}>Resolution
slider4:gate=1<0.1,1,0.1>Gate
slider5:velocity=0<0,127,1>Velocity (0=use played velocity)
slider6:lfo_wave=0<0,2,1{Sawtooth,Triangle,Square}>Velocity LFO Wave
slider7:lfo_steps=16<2,30,1>Velocity LFO Steps
slider8:lfo_amount=0<-127,127,1>Velocity LFO Amount
slider9:retrigger=0<0,1,1{Rest,Any Note Change}>Retrigger On
slider10:single_note=0<0,1,1{No,Yes}>Single-Note Playthrough

in_pin:none
out_pin:none

@init
notes = 0000; num_notes = 0; num_notes_prev = 0;
pool  = 1000; pool_size = 0;
steps = 2000; num_steps = 0;
nvmap = 3000;
pvmap = 4000;
svmap = 5000;
note = -1;
step = -1;
step_count = 0;
step_length = 0;
time = 0;
algo = 0;
octaves = 0;

// inserts note into the sorted list of playing notes
function add_note(n, v) local(i, x, tmp) (
  x = -1;
  i = 0; while(i > -1 && i <= num_notes) (
    x < 0 ? (
      notes[i] == n ? (
        i = -1; // duplicate, don't add
      ) : (i < 1 || notes[i - 1] < n) && (i === num_notes || notes[i] > n) ? (
        x = i;
        nvmap[n] = v;
      );
    );

    x > -1 && i >= x ? (
      tmp = notes[i];
      notes[i] = n;
      n = tmp;
    );

    i += 1;
  );

  x > -1 ? num_notes += 1;
  /* return */ i;
);

// removes note from list of playing notes
function rem_note(n) local(i, x) (
  x = -1;
  i = 0; while (i < num_notes) (
    x < 0 && notes[i] == n ? x = i;
    x > -1 && i >= x ? (
      notes[i] = notes[i+1];
      notes[i + 1] = 0;
    );
    i += 1;
  );

  x > -1 ? num_notes -= 1;
  /* return */ x;
);

// maps note and velocity to the specified step
function map_step(s, n) (
  steps[s] = pool[n % pool_size];
  svmap[s] = pvmap[n % pool_size];
);

function generate_notes_pool() local(n) (
  pool_size = num_notes * octaves; 

  n = 0; while (n < pool_size) (
    pool[n] = notes[n % num_notes] + (12 * floor(n / num_notes));
    pvmap[n] = nvmap[notes[n % num_notes]];
    n += 1;
  );

  /* return */ pool_size;
);

function generate_steps_unidirectional(d, o) local(n, s) (
  num_steps = generate_notes_pool();

  s = 0; n = d < 0 ? pool_size - 1 : 0; while (s < num_steps) (
    map_step(s + o, n);
    s += 1;
    n += d;
  );

  /* return */ num_steps;
);

function generate_steps_updown(d) local(ns1, ns2) (
  ns1 = generate_steps_unidirectional(1, 0) - d;
  ns2 = generate_steps_unidirectional(-1, ns1) - d;
  /* return */ num_steps = ns1 + ns2;
);

function generate_steps_downup(d) local(ns1, ns2) (
  ns1 = generate_steps_unidirectional(-1, 0) - d;
  ns2 = generate_steps_unidirectional(1, ns1) - d;
  /* return */ num_steps = ns1 + ns2;
);

function generate_steps_join(o) local(n, s) (
  num_steps = generate_notes_pool();

  s = 0; n = 0; while (s < num_steps) (
    map_step(s + o, n);
    s += 1;
    n += (s % 2 == 0) ? s - num_steps : num_steps - s;
  );

  /* return */ num_steps;
);

function generate_steps_spread(o) local(n, s) (
  num_steps = generate_notes_pool();

  s = 0; n = floor(pool_size / 2); while (s < num_steps) (
    map_step(s + o, n);
    s += 1;
    n += ((num_steps - s) % 2 == 0) ? s : -s;
  );

  /* return */ num_steps;
);

function generate_steps_joinspread() local(ns1, ns2) (
  ns1 = generate_steps_join(0) - 1;
  ns2 = generate_steps_spread(ns1) - 1;
  /* return */ num_steps = ns1 + ns2;
);

function generate_steps_spreadjoin() local(ns1, ns2) (
  ns1 = generate_steps_spread(0) - 1;
  ns2 = generate_steps_join(ns1) - 1;
  /* return */ num_steps = ns1 + ns2;
);

function generate_steps() (
  num_notes <= 0 ? (num_steps = 0; pool_size = 0) :
  num_notes == 1 ? generate_steps_unidirectional(1, 0) :
  algo == 0 ? generate_steps_unidirectional(1, 0) :
  algo == 1 ? generate_steps_unidirectional(-1, 0) :
  algo == 2 ? generate_steps_updown(1) :
  algo == 3 ? generate_steps_updown(0) :
  algo == 4 ? generate_steps_downup(1) :
  algo == 5 ? generate_steps_downup(0) :
  algo == 6 ? generate_steps_join(0) :
  algo == 7 ? generate_steps_spread(0) :
  algo == 8 ? generate_steps_joinspread() :
  algo == 9 ? generate_steps_spreadjoin();
);

function compute_step_length() local(t, n, f) (
  t = 60 / tempo;
  n = 2 ^ (floor(resolution / 3) - 4);
  f = resolution % 3;
  f == 0 ? f = 2/3 : f == 2 ? f = 3/2;
  step_length = t * n * f;
);

function process_midi() local(tr, offset, msg1, msg2, msg3) (
  tr = 0;

  while (midirecv(offset, msg1, msg2, msg3)) (
    // normalize note on / velocity 0 to note off
    msg1 == $x90 && msg3 == 0 ? (
      msg1 = $x80;
    );

    msg1 == $x90 ? (
      add_note(msg2, msg3) > -1 ? tr = 1;
    ) : msg1 == $x80 ? (
      rem_note(msg2) > -1 ? tr = 1;
    ) : (
      // passthru
      midisend(offset, msg1, msg2, msg3);
    );
  );

  /* return */ tr;
);

// From https://rosettacode.org/wiki/Map_range
function map_range(s, a1, a2, b1, b2) (
  /* return */ b1 + (s - a1) * (b2 - b1) / (a2 - a1);
);

function get_velocity(s) local(v, target, v1, v2) (
  v = velocity > 0 ? velocity : svmap[s];

  lfo_amount != 0 && num_notes > single_note ? (
    target = min(max(v + lfo_amount, 0), 127);

    // sawtooth wave
    lfo_wave == 0 ? v = map_range(step_count % lfo_steps, 0, lfo_steps - 1, v, target);

    // triangle wave
    lfo_wave == 1 ? (
      floor(step_count / (lfo_steps - 1)) % 2 == 0 ? (v1 = v; v2 = target) : (v1 = target; v2 = v);
      v = map_range(step_count % (lfo_steps - 1), 0, lfo_steps - 1, v1, v2);
    );

    // square wave
    lfo_wave == 2 ? v = floor(step_count / lfo_steps) % 2 == 0 ? v : target;
  );

  /* return */ v;
);

function restart_seq() (
  // stop current note, if any
  note > -1 ? (
    midisend(0, $x80, note, 0);
    note = -1;
  );

  // restart
  time = 0;
  step = -1;
  step_count = 0;

  // if there is at least one note in the array, start playing it
  num_steps > 0 ? (
    step = 0;
    note = steps[step];
    midisend(0, $x90, note, get_velocity(step));
  );
);

function advance_seq() local(timestep) (
  time += 1;
  timestep = srate * step_length;

  // if we're supposed to play the next note now let's do so
  time >= timestep ? (
    time -= timestep;
    note > -1 ? midisend(0, $x80, note, 0);
    step = (step + 1) % num_steps;
    step_count += 1;
    note = steps[step];
    midisend(0, $x90, note, get_velocity(step));
  ) : note > -1 && (time / timestep) >= gate ? (
    midisend(0, $x80, note, 0);
    note = -1;
  );
);

@slider
algo != slider1 ||octaves != slider2 ? (
  algo = slider1;
  octaves = slider2;
  step = -1;
  step_count = 0;
  generate_steps();
);

@block
compute_step_length();

@sample
process_midi() > 0 ? (
  // if something changed, regenerate steps
  generate_steps();

  // (re)start sequence if needed
  step < 0 || num_notes <= single_note || num_notes_prev <= single_note || retrigger > 0 ? restart_seq();
) : num_notes > single_note ? (
  // if nothing changed & we're playing, check if we should
  // advance to the next note
  advance_seq();
);

num_notes_prev = num_notes;
