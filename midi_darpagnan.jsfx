desc:MIDI d'Arpagnan
author: jahudka
version: 1.0
changelog: Fresh out of the oven
about:
  # d'Arpagnan Arpeggiator

  I created d'Arpagnan because I wanted a simple-to-use, _predictable_,
  and still powerful arpeggiator, but I couldn't find anything that
  works and does what I need. So I rolled my own. Please beware that
  I put this together in an afternoon and it works _for me_ - it may
  not work for you, or you might not like the way it does.

  It doesn't have a fancy step sequencer. It just takes whatever you play
  and makes a sequence out of it using a deterministic algorithm with
  only a couple of parameters. You can play it live. You can use it
  in the studio. You can print out the source code and make an origami.
  Your imagination is the limit.

  ## Controls

   - `Step size` is pretty self-explanatory, I think.
   - `Algorithm` offers four choices:
      - `up` plays the notes from the lowest to the highest,
      - `down` does the mirror opposite,
      - `up&down` does one `up` and then one `down` (e.g. `cegCCgeccegCCgec...`), and
      - `up&down alt` does the same, except it deduplicates
        the last note of each cycle, so for example `cegCgecegCgec...`.
   - `Octaves` is used to add octaves above the played notes. It does exactly
     the same thing as if you added transposed copies of all the notes you play.
   - `Note length` can be used to make the emitted notes shorter.
     By default the notes are the full specified `Step size` long, but
     at 1/32 triplets at 180bpm stuff gets crazy sometimes and notes could
     overlap, and overlapping notes could cause hanging tones. Bringing
     note length back to 90% can be usually compensated by a slightly longer
     decay on the synth to sound the same while avoiding this issue.
   - `Retrigger` allows you to choose whether to restart the sequence
     from the beginning when any one note is changed (ie. added or removed),
     or only when there's a period of silence (even if it's only a millisecond long).


slider1:0<0,3,1{Up,Down,Up&Down,Up&Down Alt}>Algorithm
slider2:1<1,4,1>Octaves
slider3:7<0,23,1{1/64 Triplet,1/64,1/64 Dotted,1/32 Triplet,1/32,1/32 Dotted,1/16 Triplet,1/16,1/16 Dotted,1/8 Triplet,1/8,1/8 Dotted,1/4 Triplet,1/4,1/4 Dotted,1/2 Triplet,1/2,1/2 Dotted,1/1 Triplet,1/1,1/1 Dotted,2/1 Triplet,2/1,2/1 Dotted}>Resolution
slider4:gate=1<0.1,1,0.1>Gate
slider5:velocity=0<0,127,1>Velocity (0=use played velocity)
slider6:retrigger=0<0,1,1{No,Yes}>Retrigger on note change

in_pin:none
out_pin:none

@init
notes = 1024; num_notes = 0; num_notes_prev = 0;
steps = 2048; num_steps = 0;
nvmap = 4096;
note = -1;
step = -1;
step_length = 0;
t = 0;
algo = 0;
octaves = 0;
resolution = 0;

// inserts note into the sorted list of playing notes
function add_note(n v) local(i x tmp) (
  x = -1;
  i = 0; while(i > -1 && i <= num_notes) (
    x < 0 ? (
      notes[i] == n ? (
        i = -1; // duplicate, don't add
      ) : (i < 1 || notes[i - 1] < n) && (i === num_notes || notes[i] > n) ? (
        x = i;
        nvmap[n] = v;
      );
    );

    x > -1 && i >= x ? (
      tmp = notes[i];
      notes[i] = n;
      n = tmp;
    );

    i += 1;
  );

  x > -1 ? num_notes += 1;
  /* return */ i;
);

// removes note from list of playing notes
function rem_note(n) local(i x) (
  x = -1;
  i = 0; while (i < num_notes) (
    x < 0 && notes[i] == n ? x = i;
    x > -1 && i >= x ? (
      notes[i] = notes[i+1];
      notes[i + 1] = 0;
    );
    i += 1;
  );

  x > -1 ? num_notes -= 1;
  /* return */ x;
);

function generate_octaves(d o) local(s v) (
  // if generating octaves below, transpose existing steps
  octaves > 1 && d < 0 ? (
    s = 0; while (s < num_steps) (
      v = nvmap[steps[s + o]];
      steps[s + o] = steps[s + o] + (12 * (octaves - 1));
      nvmap[steps[s + o]] = v;
      s += 1;
    );
  );

  // insert additional transposed steps
  s = num_steps; while (s < num_steps * octaves) (
    steps[s + o] = steps[(s % num_steps) + o] + (12 * floor(s / num_steps) * d);
    nvmap[steps[s + o]] = nvmap[steps[(s % num_steps) + o]];
    s += 1;
  );

  /* return */ num_steps = num_steps * octaves;
);

function generate_steps_unidirectional(d o) local (n s) (
  num_steps = num_notes;

  s = 0; n = d < 0 ? num_notes - 1 : 0; while (s < num_steps) (
    steps[s + o] = notes[n % num_notes];
    s += 1;
    n += d;
  );

  /* return */ num_steps = generate_octaves(d, o);
);

function generate_steps_updown(d) local (ns1 ns2) (
  ns1 = generate_steps_unidirectional(1, 0) - d;
  ns2 = generate_steps_unidirectional(-1, ns1) - d;
  /* return */ num_steps = ns1 + ns2;
);

function generate_steps() (
  num_notes <= 1 ? (
    steps[0] = notes[0];
    num_steps = num_notes;
  ) : (
    algo == 0 ? generate_steps_unidirectional(1, 0) :
    algo == 1 ? generate_steps_unidirectional(-1, 0) :
    algo == 2 ? generate_steps_updown(0) :
    algo == 3 ? generate_steps_updown(1);
  );
);

function compute_step_length() local (t, n, f) (
  t = 60 / tempo;
  n = 2 ^ (floor(resolution / 3) - 4);
  f = resolution % 3;
  f == 0 ? f = 2/3 : f == 2 ? f = 3/2;
  step_length = t * n * f;
);

function process_midi() local (tr offset msg1 msg2 msg3) (
  tr = 0;

  while (midirecv(offset, msg1, msg2, msg3)) (
    // normalize note on / velocity 0 to note off
    msg1 == $x90 && msg3 == 0 ? (
      msg1 = $x80;
    );

    msg1 == $x90 ? (
      add_note(msg2, msg3) > -1 ? tr = 1;
    ) : msg1 == $x80 ? (
      rem_note(msg2) > -1 ? tr = 1;
    ) : (
      // passthru
      midisend(offset, msg1, msg2, msg3);
    );
  );

  /* return */ tr;
);

function get_velocity(n) (
  /* return */ velocity == 0 ? nvmap[n] : velocity;
);

function restart_seq() (
  // stop current note, if any
  note > -1 ? (
    midisend(0, $x80, note, 0);
    note = -1;
  );

  // restart
  t = 0;
  step = -1;

  // if there is at least one note in the array, start playing it
  num_steps > 0 ? (
    step = 0;
    note = steps[step];
    midisend(0, $x90, note, get_velocity(note));
  );
);

function advance_seq() local (p pi s) (
  p = t / (srate * step_length);
  pi = floor(p);
  s = pi % num_steps;

  // if we're supposed to play the next note now let's do so
  s != step ? (
    note > -1 ? midisend(0, $x80, note, 0);
    step = s;
    note = steps[step];
    midisend(0, $x90, note, get_velocity(note));
  ) : note > -1 && (p - pi) >= gate ? (
    midisend(0, $x80, note, 0);
    note = -1;
  );
);

@slider
algo != slider1 ||octaves != slider2 || resolution != slider3 ? (
  // if a main slider changed, reset step state
  step = -1;
  t = 0;
  algo = slider1;
  octaves = slider2;
  resolution = slider3;
  generate_steps();
);

@block
compute_step_length();

@sample
t = (t + 1) % (srate * step_length * num_steps);

// process midi
process_midi() > 0 ? (
  // if something changed, regenerate steps
  generate_steps();

  // (re)start sequence if needed
  step < 0 || num_notes <= 1 || num_notes_prev <= 1 || retrigger > 0 ? restart_seq();
) : num_notes > 1 ? (
  // if nothing changed & we're playing, check if we should
  // advance to the next note
  advance_seq();
);

num_notes_prev = num_notes;
